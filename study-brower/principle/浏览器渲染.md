### 浏览器渲染

**我们知道电脑屏幕上内容的显示靠的都是显卡，那么如何将内容显示在屏幕上，也是一个技术活。不同的应用使用的方式都不一样，但追求的都是最好最佳的。不扯这么多没用的了，说说浏览器的整个渲染机制。**

#### 现代浏览器的架构

*以Google chrome浏览器为例*

浏览器从单进程发展到多进程，如今大致包括：
1. 浏览器进程
2. GPU进程
3. 网络进程
4. 多个渲染进程(*这就是将一个html文件渲染到屏幕的幕后英雄*)  
	 **我们来一起揭开它的神秘面纱吧！按照渲染的时间顺序分为以下几个阶段：构建DOM树、样式计算、布局、分层、绘制、分块、光栅化、合成。按照进程中线程分为：主线程(main thread)、工作线程(work thread)、合成线程(compositor thread)、光栅化线程(raster thread)**
	 > 构建DOM树 

	浏览器会将html文件转换为一棵DOM树。另外在构建DOM树的过程中，**主线程**会去**缓存或者网络**上请求一些图片、css、js等资源文件。这时，对于需要从网络上获取的资源，要通过**进程之间的通信(IPC)** 通知**网络进程**去下载，这很合理。在遇到<script\>标签的时候,解析DOM树的工作会暂停，等js文件中代码执行完毕再继续去解析，所以啊，一定要再最前面或者最后去引入js文件，防止出现错误。

	 > 样式计算
	 
	 样式计算是为了获取每个节点的样式，分为三步来进行。**主进程**将css文件转成styleSheets结构，这个结构支持查询和修改，可以在浏览器开发者工具通过document.styleSheets打印出来。我们知道css中单位有很多，例如rem、vh、vw等，可惜啊！渲染引擎不识别，要将这些转化为标准样式px，此外颜色如blue转化为rgba。那么获取样式表之后呢？就要计算每个节点的样式了，机制是css的继承规则和层叠规则。

	 > 布局阶段

	 那么每个元素在屏幕的哪个位置呢？只有上述的两个过程是不行的，布局阶段分为合成布局树和计算节点位置。布局树和DOM树类似，差别就是布局树只包含可见节点，不包含如 (空格)元素和display:none样式的元素。**主线程**会计算出每个元素的位置信息以及盒子大小。

	 > 分层

	 好了，经过上一步确定了每个元素的位置，是不是就可以进行绘制了呢？No，还要分层哟。因为页面上有很多复杂的效果，比如滑动、z-index等，**主线程**还需要为特定的阶段生成专用的图层，并对应一棵图层树。这里需要了解的是，哪些元素会被单独分层，因为布局树和图层树不是一一对应的关系，也就是说不是每个布局树的节点都会生成一个单独的图层树节点，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。那么使节点生成特定图层的操作如下：
	 - 拥有层叠上下文属性的元素。浏览器是一个二维的，但是层叠上下文让元素有了三维的概念。如：z-index、position、css滤镜、3D或透视、opacity、Video元素、canvas元素，两个html元素来凑什么热闹？
	 - 需要裁剪的地方。就是需要滚动的地方，里面的内容会单独生成一个图层，如果有滚动条，它也会生成一个图层。

	 > 图层绘制

	 完成图层的绘制之后，**主线程**会对每个图层进行绘制，这里需要注意！此时的绘制不是说真正的绘制画面，而是生成一个绘制指令列表。把每个图层的绘制拆分成很多的绘制指令，感觉很平常啊，做什么不都是有步骤的吗，对于计算机来说，就是靠的指令啊。只不过这一阶段并不执行指令。

	 > 栅格化

	 当当当...，**合成线程**登场！实际的绘制操作是由它执行的。合成线程会将图层划分为**图块**，因为浏览器的视口是有限的，有些图层可能会非常大，所以不会将其都渲染出来，想象一下如果都渲染的话，多耗费资源啊，所以划分为图块。**栅格化子进程**会将视口区域内的图块转化为**位图(磁贴)**，这时渲染进程会通过IPC通信协议通知**GPU进程**将位图存入GPU显存中。

	 > 合成和显示

	 所有图块都被栅格化之后，**合成进程**会收集位图信息来创建**合成帧**，这时使用IPC通知**浏览器主进程**，将页面内容绘制到内存中，然后再将内存中内容显示在屏幕上。

	 *需要指出的是，以上的所有操作都需要实打实的计算机底层结构的支撑，例如传输数据的带宽、内存等等，所以要特别注意性能的优化。例如图层过多就会使性能下降，造成卡顿。*

5. 多个插件进程


